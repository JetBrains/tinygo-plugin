{
  parserClass="org.jetbrains.tinygoplugin.lang.avrAsm.parser.AvrAsmParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="AvrAsm"
  psiImplClassSuffix="Impl"
  psiPackage="org.jetbrains.tinygoplugin.lang.avrAsm.psi"
  psiImplPackage="org.jetbrains.tinygoplugin.lang.avrAsm.psi.impl"

  elementTypeHolderClass="org.jetbrains.tinygoplugin.lang.avrAsm.psi.AvrAsmTypes"
  elementTypeClass="org.jetbrains.tinygoplugin.lang.avrAsm.psi.AvrAsmElementType"
  tokenTypeClass="org.jetbrains.tinygoplugin.lang.avrAsm.psi.AvrAsmTokenType"
}

asmFile ::= (preprocessor | LABEL | instruction | directive | LINE_COMMENT | BLOCK_COMMENT)*

preprocessor ::= MACROS_NAME | (PREPROCESSOR_NAME (expression)*) {recoverWhile=recovery}

directive                 ::= (set_directive | equ_directive | def_directive | db_directive | report_directive | generic_directive) {recoverWhile=recovery}
private generic_directive ::= GENERIC_DIRECTIVE (<<list_of expression>> | EQUAL expression)?
private set_directive     ::= SET_DIRECTIVE variable EQUAL expression
variable                  ::= symbol
private equ_directive     ::= EQU_DIRECTIVE const EQUAL expression
const                     ::= symbol
private def_directive     ::= DEF_DIRECTIVE symbol EQUAL REGISTER
private db_directive      ::= DB_DIRECTIVE <<list_of (expression | STRING)>>
private report_directive  ::= REPORT_DIRECTIVE STRING

instruction ::= (branch_instruction | generic_instruction) {recoverWhile=recovery}
private generic_instruction ::= MNEMONIC <<max_two_list argument>>?
private branch_instruction  ::= BR_MNEMONIC (IDENTIFIER | (INTEGER COMMA IDENTIFIER))?
argument ::= memory | expression

private recovery   ::= !(PREPROCESSOR_NAME | MACROS_NAME | LABEL | directives | mnemonics | LINE_COMMENT)
private directives ::= GENERIC_DIRECTIVE | EQU_DIRECTIVE | SET_DIRECTIVE | DEF_DIRECTIVE | DB_DIRECTIVE | REPORT_DIRECTIVE
private mnemonics  ::= MNEMONIC | BR_MNEMONIC

expression ::= arithmetic_expr

private arithmetic_expr ::= unary | factor (plus_expr | bitwise_expr)*
unary ::= (TILDA | MINUS) arithmetic_expr

private factor ::= primary mul_expr*
left mul_expr ::= (STAR | DIVISION) primary
left plus_expr ::= (PLUS | MINUS) factor
left bitwise_expr ::= (SHIFT_LEFT | SHIFT_RIGHT | AMP | XOR | OR) factor

private primary ::=  literal_expr | ref_expr | paren_expr
paren_expr ::= L_PAREN expression R_PAREN {pin=1}
ref_expr ::= call | symbol
literal_expr ::= PC | number

memory           ::= REGISTER | indirect_postfix | indirect_prefix | INDIRECT
indirect_prefix  ::= (MINUS | PLUS) INDIRECT
indirect_postfix ::= INDIRECT (MINUS | PLUS)

symbol ::= (IDENTIFIER | SYMBOL_IDENTIFIER)
number ::= MINUS? (INTEGER | CHAR)
call   ::= defined | strlen | generic_func
private defined      ::= (DEFINED_FUNC <<parenthesized (symbol)>>)
private strlen       ::= (STRLEN_FUNC <<parenthesized (STRING)>>)
private generic_func ::= (FUNC <<parenthesized <<list_of expression>> >>)


private meta max_two_list  ::= <<element>> ( COMMA <<element>> )?
private meta list_of       ::= <<element>> ( COMMA <<element>> )*
private meta parenthesized ::= L_PAREN <<param>> R_PAREN
